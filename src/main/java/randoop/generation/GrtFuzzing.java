package randoop.generation;

import java.lang.reflect.Constructor;
import java.lang.reflect.Executable;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import randoop.main.GenInputsAbstract;
import randoop.main.RandoopBug;
import randoop.operation.CallableOperation;
import randoop.operation.ConstructorCall;
import randoop.operation.MethodCall;
import randoop.operation.TypedClassOperation;
import randoop.operation.TypedOperation;
import randoop.sequence.Sequence;
import randoop.types.NonParameterizedType;
import randoop.types.Type;
import randoop.types.TypeTuple;
import randoop.util.Randomness;

/**
 * Implements the "GRT Impurity" component, as described in "GRT: Program-Analysis-Guided Random
 * Testing" by Ma et. al (ASE 2015): https://people.kth.se/~artho/papers/lei-ase2015.pdf.
 *
 * <p>The GRT Impurity component (Will be referred to as "GRT Fuzzing") is a fuzzing mechanism that
 * alters the states of (or creates new) input objects for methods under test to generate more
 * object states and potentially trigger more branches, improving coverage for the program under
 * test.
 *
 * <p>[TODO: As described in the GRT paper, "GRT Fuzzing" also generates more effective test with
 * shorter length by reducing the number of redundant sequences that do not side-effect the state of
 * an object. That is not implemented here.]
 *
 * <p>For details about fuzzing, see {@link #fuzz}.
 */
@SuppressWarnings("NotJavadoc") // perhaps https://github.com/google/error-prone/issues/3904
public class GrtFuzzing {

  /** Ways to fuzz a string. */
  private enum StringFuzzingOperation {
    /** Insert a random character at a random index in the string. */
    INSERT,

    /** Remove a character at a random index in the string. */
    REMOVE,

    /** Replace a character at a random index in the string with a random character. */
    REPLACE,

    /** Take a random substring of the string. */
    SUBSTRING
  }

  /** The standard deviation of the Gaussian distribution used to generate fuzzed numbers. */
  private static final double GAUSSIAN_STD = GenInputsAbstract.grt_fuzzing_stddev;

  /** Do not instantiate. */
  private GrtFuzzing() {
    throw new Error("Do not instantiate");
  }

  /**
   * Generate an extended fuzzed sequence for the given sequence.
   *
   * <p>This is the main entry point for GRT Fuzzing. This method appends additional fuzzing
   * statements to the input sequence to fuzz the input object. This will generate more object
   * states and potentially improve coverage for the unit test generated by Randoop by triggering
   * more branches.
   *
   * <p>Different types have different fuzzing strategies:
   *
   * <ul>
   *   <li><b>Numbers (int, short, long, float, double, and their wrapper classes):</b> Fuzzed using
   *       a Gaussian distribution with the original value as the mean (mu). The fuzzed value is
   *       generated as mu + N(0, GAUSSIAN_STD). For short values, if the fuzzed value exceeds the
   *       short range, it is truncated.
   *   <li><b>Strings:</b> A random fuzzing operation is selected from the {@link
   *       StringFuzzingOperation} enum.
   *   <li><b>Other Objects:</b> [TODO: Further implementation required] Methods are analyzed for
   *       side-effects to enhance test effectiveness by focusing on these interactions.
   * </ul>
   *
   * <p>This method does not fuzz void, char, boolean, or byte types.
   *
   * @param sequence the (non-null) sequence to fuzz
   * @return a sequence consisting of {@code sequence} with additional fuzzing statements appended
   *     at the end, and a count of the number of fuzzing statements added. If no fuzzing statements
   *     are added, the original sequence is returned, and the count is 0.
   */
  public static GrtFuzzingAndNumStatements fuzz(Sequence sequence) {
    // The number of fuzzing statements added to the sequence.
    FuzzStatementNumber fuzzStatementNumber = new FuzzStatementNumber();

    Type outputType = sequence.getLastVariable().getType();

    // Do not fuzz void, char, boolean, or byte.
    if (outputType.isVoid()
        || outputType.runtimeClassIs(char.class)
        || outputType.runtimeClassIs(Character.class)
        || outputType.runtimeClassIs(boolean.class)
        || outputType.runtimeClassIs(Boolean.class)
        || outputType.runtimeClassIs(byte.class)
        || outputType.runtimeClassIs(Byte.class)) {
      return new GrtFuzzingAndNumStatements(sequence, 0);
    }

    Class<?> outputClass = outputType.getRuntimeClass();
    List<Executable> fuzzingOperations = new ArrayList<>();

    // Append input statements for fuzzing operations to the sequence.
    try {
      if (outputClass.isPrimitive()) { // fuzzing primitive numbers
        sequence = appendGaussianSampleSequence(sequence, outputClass);
        fuzzingOperations = getNumberFuzzingMethods(outputClass);
      } else if (outputClass == String.class) { // fuzzing String
        // Randomly select a fuzzing operation for String.
        StringFuzzingOperation operation =
            StringFuzzingOperation.values()[
                Randomness.nextRandomInt(StringFuzzingOperation.values().length)];
        sequence = appendStringFuzzingInputs(sequence, operation, fuzzStatementNumber);
        if (fuzzStatementNumber.offset == 0) { // sequence not fuzzed, return original sequence
          return new GrtFuzzingAndNumStatements(sequence, 0);
        }
        fuzzingOperations = getStringFuzzingMethod(operation);
      } else {
        // TODO: Fuzz other objects based on purity analysis
        //  return the original sequence for now
        return new GrtFuzzingAndNumStatements(sequence, 0);
      }
    } catch (Exception e) { // All other exceptions are unexpected
      throw new RandoopBug("GRT Fuzzing failed: " + e.getMessage(), e);
    }

    Sequence output = sequence;

    // TODO: Implement cast to improve short fuzzing output readability
    //  (e.g. cast to Integer for Integer.sum when fuzzing short can make Integer.valueOf()
    //  unnecessary).

    // Append fuzzing operation statements to the sequence.
    for (Executable executable : fuzzingOperations) {
      output = appendFuzzingOperation(output, executable, getOutputType(executable), fuzzStatementNumber);
    }

    return new GrtFuzzingAndNumStatements(output, fuzzStatementNumber.offset);
  }

  /**
   * Create a new sequence with a fuzzing operation statement appended to the given sequence.
   *
   * @param sequence the sequence to append the fuzzing operations to
   * @param fuzzingOperation the method to be invoked to fuzz the object
   * @param outputType the output type of the fuzzing operation
   * @param fuzzStatementNumber the offset counter for the number of fuzzing statements added
   * @return a sequence with the fuzzing statement appended at the end
   */
  private static Sequence appendFuzzingOperation(
      Sequence sequence,
      Executable fuzzingOperation,
      Type outputType,
      FuzzStatementNumber fuzzStatementNumber) {
    CallableOperation callableOperation = createCallableOperation(fuzzingOperation);
    NonParameterizedType declaringType =
        new NonParameterizedType(fuzzingOperation.getDeclaringClass());
    List<Type> inputTypeList = getInputTypeList(fuzzingOperation, declaringType);
    TypeTuple inputType = new TypeTuple(inputTypeList);
    TypedOperation typedOperation =
        new TypedClassOperation(callableOperation, declaringType, inputType, outputType);
    List<Integer> inputIndex = calculateInputIndices(sequence, inputTypeList.size());
    fuzzStatementNumber.increment(inputTypeList.size());
    List<Sequence> sequenceList = Collections.singletonList(sequence);
    return Sequence.createSequence(typedOperation, sequenceList, inputIndex);
  }

  /**
   * Create a callable operation given the executable.
   *
   * @param executable the executable to create the callable operation for
   * @return a callable operation for the given executable
   */
  private static CallableOperation createCallableOperation(Executable executable) {
    if (executable instanceof Method) {
      return new MethodCall((Method) executable);
    } else {
      return new ConstructorCall((Constructor<?>) executable);
    }
  }

  /**
   * Returns the output type of the given executable.
   *
   * @param executable the executable to get the output type of
   * @return the output type of the given executable
   */
  private static Type getOutputType(Executable executable) {
    return Type.forType(executable.getAnnotatedReturnType().getType());
  }

  /**
   * Get the list of input types for the given executable.
   *
   * @param executable the executable to get the input types of
   * @param declaringType the type that declares the given executable
   * @return the list of input types for the given executable
   */
  private static List<Type> getInputTypeList(
      Executable executable, NonParameterizedType declaringType) {
    List<Type> inputTypeList = new ArrayList<>();
    if (!Modifier.isStatic(executable.getModifiers()) && executable instanceof Method) {
      inputTypeList.add(declaringType);
    }
    for (Class<?> cls : executable.getParameterTypes()) {
      inputTypeList.add(Type.forClass(cls));
    }
    return inputTypeList;
  }

  /**
   * Calculate the indices of statements in the sequence that are the inputs for the fuzzing
   * operation. Precondition: The input statements are the last n statements in the sequence, where
   * n is the number of input types.
   *
   * @param sequence the sequence to calculate the input indices of
   * @param inputTypeListSize the number of input types of the given executable
   * @return the indices of statements in the sequence that are the inputs for the fuzzing operation
   */
  private static List<Integer> calculateInputIndices(Sequence sequence, int inputTypeListSize) {
    List<Integer> inputIndices = new ArrayList<>();
    int firstIndex = sequence.size() - inputTypeListSize;
    for (int i = 0; i < inputTypeListSize; i++) {
      inputIndices.add(firstIndex + i);
    }
    return inputIndices;
  }

  /**
   * Create a statement representing a Gaussian sampling result and append it to the given sequence.
   *
   * @param sequence the sequence to append the Gaussian sampling result to
   * @param cls the class of the Gaussian number to be generated and appended
   * @return a sequence with the Gaussian sampling result appended at the end
   */
  private static Sequence appendGaussianSampleSequence(Sequence sequence, Class<?> cls) {
    Object gaussianSample = generateGaussianSample(cls);
    Sequence gaussianSampleSequence = Sequence.createSequenceForPrimitive(gaussianSample);
    return Sequence.concatenate(sequence, gaussianSampleSequence);
  }

  /**
   * Generate a random Gaussian sample value N(0, GAUSSIAN_STD) of the given class.
   *
   * @param cls the class of the number to be generated
   * @return a Gaussian sample value with 0 mean and a predefined standard deviation
   */
  private static Object generateGaussianSample(Class<?> cls) {
    double randomGaussian = GAUSSIAN_STD * Randomness.nextRandomGaussian(1);
    if (cls == int.class || cls == Integer.class) {
      return (int) Math.round(randomGaussian);
    } else if (cls == short.class || cls == Short.class) {
      return (short) Math.round(randomGaussian);
    } else if (cls == long.class || cls == Long.class) {
      return Math.round(randomGaussian);
    } else if (cls == float.class || cls == Float.class) {
      return (float) randomGaussian;
    } else if (cls == double.class || cls == Double.class) {
      return randomGaussian;
    } else {
      throw new RuntimeException("Unexpected primitive type: " + cls.getName());
    }
  }

  /**
   * Get the methods for fuzzing primitive numbers of the given class.
   *
   * @param cls a numeric class
   * @return a list of methods that will, together, be used to fuzz a number of the given class
   */
  private static List<Executable> getNumberFuzzingMethods(Class<?> cls)
      throws NoSuchMethodException {
    List<Executable> methodList = new ArrayList<>();

    if (cls == int.class || cls == Integer.class) {
      methodList.add(Integer.class.getMethod("sum", int.class, int.class));
    } else if (cls == double.class || cls == Double.class) {
      methodList.add(Double.class.getMethod("sum", double.class, double.class));
    } else if (cls == float.class || cls == Float.class) {
      methodList.add(Float.class.getMethod("sum", float.class, float.class));
    } else if (cls == long.class || cls == Long.class) {
      methodList.add(Long.class.getMethod("sum", long.class, long.class));
    } else if (cls == short.class || cls == Short.class) {
      // Short doesn't have a sum method, so we use Integer.sum and get the short value
      methodList.add(Integer.class.getMethod("sum", int.class, int.class));
      methodList.add(Integer.class.getMethod("valueOf", int.class));
      methodList.add(Integer.class.getMethod("shortValue"));
    } else {
      throw new IllegalArgumentException("Unexpected primitive type: " + cls.getName());
    }

    return methodList;
  }

  /**
   * Create and append all statements needed for the String fuzzing operation to the given sequence.
   * Precondition: Length of the input String to be fuzzed is not 0.
   *
   * @param sequence the (non-empty) sequence to append the String fuzzing operation inputs to
   * @param operation the String fuzzing operation to perform
   * @param fuzzStatementNumber the offset counter for the number of fuzzing statements added
   * @return a sequence with the String fuzzing operation inputs appended at the end
   */
  private static Sequence appendStringFuzzingInputs(
      Sequence sequence, StringFuzzingOperation operation, FuzzStatementNumber fuzzStatementNumber)
      throws NoSuchMethodException {
    Object stringValue = getStringValue(sequence);
    int stringLength = stringValue.toString().length();

    if (stringLength == 0 && operation != StringFuzzingOperation.INSERT) {
      return sequence; // Cannot remove/replace/substring an empty string
    }

    sequence = appendStringBuilder(sequence, fuzzStatementNumber);

    List<Sequence> fuzzingSequenceList = getStringFuzzingInputs(operation, stringLength);
    fuzzingSequenceList.add(0, sequence); // prepend

    return Sequence.concatenate(fuzzingSequenceList);
  }

  /**
   * Append a StringBuilder constructor statement to the given sequence. The string value used by
   * the StringBuilder constructor is from the last statement in the sequence.
   *
   * @param sequence the sequence to append the StringBuilder constructor to
   * @param fuzzStatementNumber the offset counter for the number of fuzzing statements added
   * @return a sequence with the StringBuilder constructor appended at the end
   */
  private static Sequence appendStringBuilder(
      Sequence sequence, FuzzStatementNumber fuzzStatementNumber) throws NoSuchMethodException {
    Constructor<?> stringBuilderConstructor = StringBuilder.class.getConstructor(String.class);
    return appendFuzzingOperation(
        sequence,
        stringBuilderConstructor,
        getOutputType(stringBuilderConstructor),
        fuzzStatementNumber);
  }

  /**
   * Get the String value from the given sequence. Precondition: The String value is the last
   * statement in the sequence.
   *
   * @param sequence the sequence to get the String value from
   * @return the String value from the given sequence
   * @throws IllegalArgumentException if the String value cannot be obtained
   */
  private static Object getStringValue(Sequence sequence) {
    try {
      return sequence.getStatement(sequence.size() - 1).getValue();
    } catch (Exception e) {
      throw new IllegalArgumentException(
          "Invalid sequence, last statement does not have a String value");
    }
  }

  /**
   * Get a list of sequences that represent the inputs for the fuzzing operation for String.
   *
   * @param operation the String fuzzing operation to perform
   * @param stringLength the length of the string to be fuzzed, for generating valid random indices
   * @return a list of sequences that represent the inputs for the fuzzing operation
   * @throws IllegalArgumentException if an invalid enum value is passed
   */
  private static List<Sequence> getStringFuzzingInputs(
      StringFuzzingOperation operation, int stringLength) {
    switch (operation) {
      case INSERT:
        return getInsertInputs(stringLength);
      case REMOVE:
        return getRemoveInputs(stringLength);
      case REPLACE:
        return getReplaceInputs(stringLength);
      case SUBSTRING:
        return getSubstringInputs(stringLength);
      default:
        throw new IllegalArgumentException(
            "Invalid enum value was passed to getStringFuzzingInputs: " + operation);
    }
  }

  /**
   * Generate the inputs as sequences for the insertion operation.
   *
   * @param stringLength the length of the string to be fuzzed
   * @return a list of sequences that represent the inputs for the insertion operation
   */
  private static List<Sequence> getInsertInputs(int stringLength) {
    int randomIndex = Randomness.nextRandomInt(stringLength + 1);
    char randomChar = (char) (Randomness.nextRandomInt(95) + 32); // ASCII 32-126
    Sequence randomIndexSequence = Sequence.createSequenceForPrimitive(randomIndex);
    Sequence randomCharSequence = Sequence.createSequenceForPrimitive(randomChar);
    return Arrays.asList(randomIndexSequence, randomCharSequence);
  }

  /**
   * Generate a random index as sequence for the removal operation.
   *
   * @param stringLength the length of the string to be fuzzed
   * @return a sequence (singleton) that represent the input for the removal operation
   */
  private static List<Sequence> getRemoveInputs(int stringLength) {
    int randomIndex = Randomness.nextRandomInt(stringLength);
    Sequence randomIndexSequence = Sequence.createSequenceForPrimitive(randomIndex);
    return Collections.singletonList(randomIndexSequence);
  }

  /**
   * Generate the inputs as sequences for the replacement operation.
   *
   * @param stringLength the length of the string to be fuzzed
   * @return a list of sequences that represent the input for the replacement operation
   */
  private static List<Sequence> getReplaceInputs(int stringLength) {
    int randomIndex1 = Randomness.nextRandomInt(stringLength);
    int randomIndex2 = Randomness.nextRandomInt(stringLength);
    int startIndex = Math.min(randomIndex1, randomIndex2);
    int endIndex = Math.max(randomIndex1, randomIndex2);
    String randomChar = String.valueOf((char) (Randomness.nextRandomInt(95) + 32)); // ASCII 32-126
    Sequence startIndexSequence = Sequence.createSequenceForPrimitive(startIndex);
    Sequence endIndexSequence = Sequence.createSequenceForPrimitive(endIndex);
    Sequence randomCharSequence = Sequence.createSequenceForPrimitive(randomChar);
    return Arrays.asList(startIndexSequence, endIndexSequence, randomCharSequence);
  }

  /**
   * Generate the inputs as sequences for the substring operation.
   *
   * @param stringLength the length of the string to be fuzzed
   * @return a list of sequences that represent the input for the substring operation
   */
  private static List<Sequence> getSubstringInputs(int stringLength) {
    int randomIndex1 = Randomness.nextRandomInt(stringLength);
    int randomIndex2 = Randomness.nextRandomInt(stringLength);
    int startIndex = Math.min(randomIndex1, randomIndex2);
    int endIndex = Math.max(randomIndex1, randomIndex2);
    Sequence startIndexSequence = Sequence.createSequenceForPrimitive(startIndex);
    Sequence endIndexSequence = Sequence.createSequenceForPrimitive(endIndex);
    return Arrays.asList(startIndexSequence, endIndexSequence);
  }

  /**
   * Get a list of methods for fuzzing the input String based on the given operation.
   *
   * @param operation the string fuzzing operation to perform
   * @return a list of methods that will be used to fuzz the input String
   * @throws NoSuchMethodException if no suitable method is found for the given operation
   * @throws IllegalArgumentException if an invalid enum value is passed
   */
  private static List<Executable> getStringFuzzingMethod(StringFuzzingOperation operation)
      throws NoSuchMethodException {
    List<Executable> methodList = new ArrayList<>();

    switch (operation) {
      case INSERT:
        methodList.add(StringBuilder.class.getMethod("insert", int.class, char.class));
        methodList.add(StringBuilder.class.getMethod("toString"));
        break;
      case REMOVE:
        methodList.add(StringBuilder.class.getMethod("deleteCharAt", int.class));
        methodList.add(StringBuilder.class.getMethod("toString"));
        break;
      case REPLACE:
        methodList.add(
            StringBuilder.class.getMethod("replace", int.class, int.class, String.class));
        methodList.add(StringBuilder.class.getMethod("toString"));
        break;
      case SUBSTRING:
        methodList.add(StringBuilder.class.getMethod("substring", int.class, int.class));
        break;
      default:
        throw new IllegalArgumentException(
            "Invalid enum value was passed to getStringFuzzingMethod: " + operation);
    }

    return methodList;
  }

  /**
   * A helper class to store the extended sequence and the number of fuzzing statements added to the
   * sequence. The number of fuzzing statements added to the sequence is needed for the forward
   * generation's input selection process to select the correct fuzzed inputs.
   */
  private static class FuzzStatementNumber {
    /** The number of fuzzing statements added to the sequence. */
    private int offset;

    /** Prevents instantiation. */
    private FuzzStatementNumber() {
      this.offset = 0;
    }

    /** Increment the number of fuzzing statements added to the sequence. */
    private void increment(int numStatements) {
      this.offset += numStatements;
    }
  }
}
